# Favorites Feature Implementation Plan

**Generated**: 2025-01-18T10:04:00Z
**Original Request**: I want to implement a feature to allow users to favorite collections/subcollections/bobbleheads. This feature will only cover an authenticated user being able to favorite/unfavorite a specific collection, subcollection or bobblehead. The managing/viewing of a users favorites will be covered in a later feature request.

## Overview

**Estimated Duration**: 3-4 days
**Complexity**: Medium
**Risk Level**: Medium

## Quick Summary

Implement a comprehensive favoriting system allowing authenticated users to favorite/unfavorite collections, subcollections, and bobbleheads. This involves creating database schema, server actions, queries, UI components, and integrating optimistic updates with TanStack Query for smooth user experience.

## Prerequisites

- [ ] Verify Clerk authentication is working properly
- [ ] Confirm TanStack Query is configured for mutations
- [ ] Ensure database connection is available for migrations

## Implementation Steps

### Step 1: Create Favorites Database Schema

**What**: Add favorites table and enum to database schema with polymorphic relationships
**Why**: Foundation for storing favorite relationships between users and favoritable entities
**Confidence**: High

**Files to Create:**

- `src/lib/db/schema/favorites.schema.ts` - Database schema for favorites table

**Files to Modify:**

- `src/lib/db/schema/index.ts` - Export favorites schema
- `src/lib/constants/enums.ts` - Add FAVORITE enum constants
- `src/lib/constants/defaults.ts` - Add favorite defaults if needed

**Changes:**

- Add favoriteTargetTypeEnum with bobblehead, collection, subcollection values
- Create favorites table with user_id, target_id, target_type, timestamps
- Add proper indexes for query performance
- Add unique constraint on userId, targetType, targetId combination
- Export favorites table from schema index

**Validation Commands:**

```bash
npm run lint:fix && npm run typecheck
```

**Success Criteria:**

- [ ] Favorites schema file exists and compiles
- [ ] Enum constants are properly defined
- [ ] Schema exports correctly from index
- [ ] All validation commands pass

---

### Step 2: Generate and Run Database Migration

**What**: Generate migration files and apply schema changes to database
**Why**: Persist the favorites table structure in the database
**Confidence**: High

**Files to Create:**

- Database migration files (auto-generated by Drizzle)

**Files to Modify:**

- None (migration files are auto-generated)

**Changes:**

- Generate migration using drizzle-kit
- Apply migration to create favorites table
- Verify table structure matches schema definition

**Validation Commands:**

```bash
npm run db:generate && npm run db:migrate
```

**Success Criteria:**

- [ ] Migration files generated successfully
- [ ] Database migration completes without errors
- [ ] Favorites table exists in database with correct structure

---

### Step 3: Create Favorites Validation Schemas

**What**: Define Zod validation schemas for favorite operations
**Why**: Ensure type safety and data validation for all favorite-related operations
**Confidence**: High

**Files to Create:**

- `src/lib/validations/favorites.validation.ts` - Zod schemas for favorite operations

**Files to Modify:**

- None

**Changes:**

- Add toggleFavoriteSchema for favorite/unfavorite operations
- Add getFavoriteStatusSchema for checking favorite status
- Add getBatchFavoriteDataSchema for batch operations
- Create TypeScript types from schemas

**Validation Commands:**

```bash
npm run lint:fix && npm run typecheck
```

**Success Criteria:**

- [ ] Validation schemas compile without errors
- [ ] Types are properly exported
- [ ] Schemas follow existing project patterns
- [ ] All validation commands pass

---

### Step 4: Create Favorites Types and Interfaces

**What**: Define TypeScript types and interfaces for favorites feature
**Why**: Provide type safety across the favorites system
**Confidence**: High

**Files to Create:**

- `src/lib/types/favorites.types.ts` - Core types for favorites feature

**Files to Modify:**

- None

**Changes:**

- Add FavoriteTargetType enum
- Create ContentFavoriteData interface
- Add FavoriteToggleResult interface
- Define batch operation types

**Validation Commands:**

```bash
npm run lint:fix && npm run typecheck
```

**Success Criteria:**

- [ ] Type definitions are complete and accurate
- [ ] Types align with validation schemas
- [ ] No TypeScript compilation errors
- [ ] All validation commands pass

---

### Step 5: Implement Favorites Database Queries

**What**: Create query layer for favorites operations using Drizzle ORM
**Why**: Provide data access methods for favorites functionality
**Confidence**: Medium

**Files to Create:**

- `src/lib/queries/favorites/favorites.query.ts` - Database queries for favorites

**Files to Modify:**

- None

**Changes:**

- Add createFavoriteAsync method
- Add deleteFavoriteAsync method
- Add getUserFavoriteStatusAsync method
- Add getBatchFavoriteDataAsync method
- Add getFavoriteCountAsync method
- Implement proper error handling and transaction support

**Validation Commands:**

```bash
npm run lint:fix && npm run typecheck
```

**Success Criteria:**

- [ ] All query methods are implemented
- [ ] Proper error handling is in place
- [ ] Transaction support is included
- [ ] Query performance is optimized
- [ ] All validation commands pass

---

### Step 6: Create Favorites Facade Layer

**What**: Implement business logic layer for favorites operations
**Why**: Centralize business rules and coordinate between queries and actions
**Confidence**: Medium

**Files to Create:**

- `src/lib/facades/favorites/favorites.facade.ts` - Business logic for favorites

**Files to Modify:**

- None

**Changes:**

- Add toggleFavorite method with business logic
- Add getContentFavoriteData method
- Add getBatchContentFavoriteData method
- Implement cache invalidation strategies
- Add proper error handling and validation

**Validation Commands:**

```bash
npm run lint:fix && npm run typecheck
```

**Success Criteria:**

- [ ] Business logic is properly implemented
- [ ] Cache strategies are defined
- [ ] Error handling follows project patterns
- [ ] Methods return consistent data structures
- [ ] All validation commands pass

---

### Step 7: Implement Favorites Server Actions

**What**: Create Next-Safe-Action server actions for favorites operations
**Why**: Provide secure, type-safe API endpoints for favorite operations
**Confidence**: Medium

**Files to Create:**

- `src/lib/actions/favorites/favorites.actions.ts` - Server actions for favorites

**Files to Modify:**

- `src/lib/constants/action-names.ts` - Add favorite action names
- `src/lib/constants/operations.ts` - Add favorite operations

**Changes:**

- Add toggleFavoriteAction with authentication
- Add getContentFavoriteDataAction
- Add getBatchContentFavoriteDataAction
- Add getPublicFavoriteCountAction
- Implement proper Sentry logging and error handling

**Validation Commands:**

```bash
npm run lint:fix && npm run typecheck
```

**Success Criteria:**

- [ ] All server actions are implemented
- [ ] Authentication checks are in place
- [ ] Error handling follows project standards
- [ ] Sentry integration is working
- [ ] All validation commands pass

---

### Step 8: Create Favorite Button Component

**What**: Build reusable favorite button component with heart icon
**Why**: Provide consistent UI for favoriting across different entity types
**Confidence**: High

**Files to Create:**

- `src/components/feature/favorites/favorite-button.tsx` - Reusable favorite button component

**Files to Modify:**

- None

**Changes:**

- Create FavoriteButton component with heart icon states
- Implement optimistic updates with TanStack Query
- Add loading, success, and error states
- Include hover effects and smooth transitions
- Support for different sizes and variants

**Validation Commands:**

```bash
npm run lint:fix && npm run typecheck
```

**Success Criteria:**

- [ ] Component renders correctly in different states
- [ ] Optimistic updates work smoothly
- [ ] Accessibility features are implemented
- [ ] Visual feedback is clear and responsive
- [ ] All validation commands pass

---

### Step 9: Create Favorites Custom Hook

**What**: Implement custom React hook for favorites functionality
**Why**: Encapsulate favorites logic and provide consistent API for components
**Confidence**: High

**Files to Create:**

- `src/hooks/use-favorite.ts` - Custom hook for favorites functionality

**Files to Modify:**

- None

**Changes:**

- Create useFavorite hook with TanStack Query integration
- Implement optimistic updates for toggle operations
- Add error handling and retry logic
- Include loading states and success feedback
- Support batch operations for lists

**Validation Commands:**

```bash
npm run lint:fix && npm run typecheck
```

**Success Criteria:**

- [ ] Hook provides clean API for components
- [ ] Optimistic updates work correctly
- [ ] Error states are handled gracefully
- [ ] Performance is optimized for lists
- [ ] All validation commands pass

---

### Step 10: Update Cache Revalidation Service

**What**: Add favorites support to existing cache revalidation service
**Why**: Ensure cache consistency when favorites change
**Confidence**: Medium

**Files to Modify:**

- `src/lib/services/cache-revalidation.service.ts` - Add favorites cache invalidation

**Changes:**

- Add onFavoriteChange method
- Implement cache tag generation for favorites
- Add revalidation strategies for favorite counts
- Integrate with existing social cache patterns

**Validation Commands:**

```bash
npm run lint:fix && npm run typecheck
```

**Success Criteria:**

- [ ] Cache invalidation works correctly
- [ ] Favorite counts update properly
- [ ] Integration with existing patterns is seamless
- [ ] No cache consistency issues
- [ ] All validation commands pass

---

### Step 11: Integrate Favorite Buttons in Collection Components

**What**: Add favorite buttons to collection-related UI components
**Why**: Allow users to favorite collections from various views
**Confidence**: High

**Files to Modify:**

- `src/app/(app)/dashboard/collection/(collection)/components/collection-card.tsx` - Add favorite button
- `src/components/feature/collections/collection.tsx` - Add favorite button if exists

**Changes:**

- Import and integrate FavoriteButton component
- Position button appropriately in layout
- Pass correct collection ID and type
- Ensure proper spacing and alignment

**Validation Commands:**

```bash
npm run lint:fix && npm run typecheck
```

**Success Criteria:**

- [ ] Favorite buttons appear in correct locations
- [ ] Button functionality works as expected
- [ ] Layout remains visually balanced
- [ ] No breaking changes to existing functionality
- [ ] All validation commands pass

---

### Step 12: Integrate Favorite Buttons in Subcollection Components

**What**: Add favorite buttons to subcollection UI components
**Why**: Enable favoriting of subcollections from listings and detail views
**Confidence**: High

**Files to Modify:**

- `src/components/feature/subcollections/subcollection.tsx` - Add favorite button if exists
- `src/components/feature/subcollections/subcollections-list-item.tsx` - Add favorite button if exists

**Changes:**

- Import FavoriteButton component
- Add button with subcollection target type
- Ensure proper positioning and styling
- Maintain existing component functionality

**Validation Commands:**

```bash
npm run lint:fix && npm run typecheck
```

**Success Criteria:**

- [ ] Subcollection favorite buttons are functional
- [ ] UI layout is preserved
- [ ] Button states update correctly
- [ ] No conflicts with existing interactions
- [ ] All validation commands pass

---

### Step 13: Integrate Favorite Buttons in Bobblehead Components

**What**: Add favorite buttons to bobblehead UI components
**Why**: Allow users to favorite individual bobbleheads
**Confidence**: High

**Files to Modify:**

- `src/components/feature/bobbleheads/bobblehead.tsx` - Add favorite button if exists
- `src/components/feature/bobbleheads/bobblehead-header.tsx` - Add favorite button if exists
- `src/components/feature/bobbleheads/bobblehead-gallery-card.tsx` - Add favorite button if exists

**Changes:**

- Integrate FavoriteButton with bobblehead target type
- Position buttons appropriately in different layouts
- Ensure consistent styling across components
- Maintain responsive design principles

**Validation Commands:**

```bash
npm run lint:fix && npm run typecheck
```

**Success Criteria:**

- [ ] Bobblehead favorite buttons work correctly
- [ ] Consistent placement across different views
- [ ] Responsive design is maintained
- [ ] Performance remains optimal
- [ ] All validation commands pass

---

### Step 14: Add Toast Notifications for Favorites

**What**: Implement user feedback through toast notifications
**Why**: Provide clear feedback for favorite/unfavorite actions
**Confidence**: High

**Files to Modify:**

- `src/hooks/use-favorite.ts` - Add toast notifications to hook
- `src/components/feature/favorites/favorite-button.tsx` - Integrate with toast system

**Changes:**

- Add success toasts for favorite/unfavorite actions
- Implement error toasts for failed operations
- Include appropriate messaging for different entity types
- Ensure toasts don't spam during rapid interactions

**Validation Commands:**

```bash
npm run lint:fix && npm run typecheck
```

**Success Criteria:**

- [ ] Toast notifications appear for all actions
- [ ] Messages are clear and helpful
- [ ] No duplicate or spam notifications
- [ ] Error handling provides useful feedback
- [ ] All validation commands pass

---

## Quality Gates

- [ ] All TypeScript files pass `npm run typecheck`
- [ ] All files pass `npm run lint:fix`
- [ ] Database migrations complete successfully
- [ ] Server actions work with proper authentication
- [ ] UI components render correctly across different entity types
- [ ] Optimistic updates function smoothly
- [ ] Cache invalidation maintains data consistency

## Notes

- The implementation follows the existing likes system architecture for consistency
- Polymorphic database design allows efficient querying across entity types
- Optimistic updates provide immediate user feedback while maintaining data integrity
- Cache invalidation strategies ensure favorite counts stay synchronized
- Error handling includes both user-facing notifications and internal logging via Sentry
- The design supports future extensions like favorite collections/lists or social features around favorites
